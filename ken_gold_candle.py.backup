"""
TradeLocker bot (Backtrader) adapted from gold_candle_ken.mq5

Key features:
- Two-candle pattern: small setup bar then big trigger bar
- Adaptive candle sizing: ATR-based OR percentile-based dynamic thresholds
- Grid recovery (optional) with ATR-based spacing and lot multiplier
- Trend filter via Moving Average
- Time window and spread filter (spread filter stubbed; requires broker-specific data)
- Take Profit management and shared TP for grid baskets
- Trailing individual stop-loss per position (optional)
- Trailing equity stop: closes all positions if drawdown from peak exceeds threshold

Adaptive Candle Sizing:
- ATR Method: Dynamically adjusts thresholds based on ATR multipliers (updates every bar)
- Percentile Method: Analyzes last 100 candles and uses percentile thresholds (updates every 100 bars)
- Mutually exclusive: Enable only one method via USE_ATR_CALCULATION or USE_PERCENTILE_CALCULATION

ATR-Based TP/SL:
- Use USE_ATR_TP_SL = True to enable ATR-based take profit and stop loss
- TP/SL automatically adapt to current market volatility
- Set TP_ATR_MULTIPLIER and SL_ATR_MULTIPLIER from optimizer results
- Example: TP = 2.0x ATR, SL = 1.0x ATR (from strategy_optimizer.py --optimize-tp-sl)

Entry Timing Fixes (High Impact):
- Fix A: ENTER_ON_OPEN = True (default) - Enter at breakout START (bar open) vs END (bar close)
  * Catches the actual breakout move instead of entering after it completes
  * Works in both backtesting and live trading
- Fix B: USE_LIMIT_ENTRY = False (default) - Wait for 50% pullback before entering
  * Instead of chasing breakouts, wait for price to retrace to limit level
  * Only enters if price comes back to test the breakout (better entry price)
  * Cancels after 5 bars if not filled
- Fix C: USE_MOMENTUM_FILTER = True (default) - Confirm breakout strength before entering
  * Checks candle closes near high/low (MIN_CANDLE_BODY_RATIO = 0.7)
  * Rejects exhausted moves (MAX_EXHAUSTION_RATIO = 3.0x ATR)
  * Optional volume confirmation (CHECK_VOLUME = False by default)

Counter-Trend Fade Strategy:
- ENABLE_COUNTER_TREND_FADE = False (default) - Fade breakouts instead of following them
  * Sells on bullish breakouts (fade retail buying exhaustion)
  * Buys on bearish breakouts (fade retail selling exhaustion)
  * Logic: Big breakout candles often represent exhaustion/traps in algo-dominated markets
  * Works best in ranging/choppy markets where breakouts fail
  * All pattern detection remains the same, only entry direction is reversed

Signal Invalidation Protection:
- ENABLE_SIGNAL_INVALIDATION = True (default) - Exit early if signal reverses
  * Monitors next N bars after entry (INVALIDATION_WINDOW_BARS = 3)
  * Exits immediately if large opposite candle forms (same size as trigger candle)
  * Example: LONG entry → large bearish candle appears → exit to prevent catastrophic loss
  * Prevents getting stuck in trades where market rejects the breakout
  * Critical for avoiding detection-execution gap losses

Account Optimization:
- Optimized for $10,000 account with minimum lot size (0.01 lots)
- Uses proper CONTRACT_SIZE = 100 for XAUUSD (1 lot = 100 oz)
- Position size validation prevents over-leverage
- Grid trading enabled with 85% max exposure allowing 2 positions (~79% actual)

Notes:
- Parameters are hardcoded per request since TradeLocker bots typically lack adjustable inputs.
- Backtrader does not provide native account equity; we track portfolio value to simulate equity.
- Spread filtering requires bid/ask; most feeds in Backtrader provide mid. A conservative stub is used.
"""

import logging
from typing import List

import backtrader as bt


class GoldCandleKenStrategy(bt.Strategy):
    # Hardcoded defaults from provided template
    # --- Core Strategy Settings ---
    MAGIC_NUMBER = 69
    LOT_SIZE = 0.03  # Minimum broker lot size for XAUUSD (1 oz = ~$3,400)
    MIN_LOT_SIZE = 0.03  # Broker's minimum lot size
    LOT_STEP = 0.03  # Broker's lot size increment
    
    # --- Adaptive Candle Size Settings ---
    USE_ATR_CALCULATION = True  # Dynamically set candle size based on ATR multipliers
    USE_PERCENTILE_CALCULATION = False  # Dynamically set candle size based on percentiles
    
    # Static candle size (used when both adaptive methods are disabled)
    BIG_CANDLE_POINTS = 150  # Increased from 140 - more selective entries
    SMALL_CANDLE_POINTS = 50  # Decreased from 140 - allow smaller setup candles
    
    # ATR-based adaptive settings (when USE_ATR_CALCULATION = True)
    ATR_SMALL_MULTIPLIER = 0.5  # Small candle = 0.35x ATR (selective)
    ATR_BIG_MULTIPLIER = 1.4  # Big candle = 1.7x ATR (strong moves)
    
    # Percentile-based adaptive settings (when USE_PERCENTILE_CALCULATION = True)
    PERCENTILE_LOOKBACK = 60    # Number of candles to analyze
    PERCENTILE_UPDATE_FREQ = 100 # Recalculate every N candles
    SMALL_CANDLE_PERCENTILE = 40 # Percentile for small candle threshold
    BIG_CANDLE_PERCENTILE = 60   # Percentile for big candle threshold

    # --- Take Profit / Stop Loss Settings ---
    # Choose between fixed points OR ATR-based (not both)
    USE_ATR_TP_SL = True  # If True, use ATR multipliers; if False, use fixed points
    
    # Fixed point-based TP/SL (used when USE_ATR_TP_SL = False)
    TAKE_PROFIT_POINTS = 200  # Fixed points
    POSITION_SL_POINTS = 100  # Fixed points (only if ENABLE_POSITION_SL = True)
    
    # ATR-based TP/SL (used when USE_ATR_TP_SL = True)
    TP_ATR_MULTIPLIER = 3.5  # Take profit = 3.0 x ATR (balanced)
    SL_ATR_MULTIPLIER = 0.3  # Stop loss = 0.4 x ATR (balanced)

    # --- Grid Settings ---
    ENABLE_GRID = False
    ATR_MULTIPLIER_STEP = 2.0  # Increased from 2.5 - wider spacing between grid levels
    LOT_MULTIPLIER = 1.1  # Decreased from 1.1 - slower position growth
    MAX_OPEN_TRADES = 3  # Limit to 2 positions for $10k account with 0.01 min lot
    GRID_PROFIT_POINTS = 150  # Match regular TP - increased from 20

    # --- Position Stop Loss Settings ---
    ENABLE_POSITION_SL = True  # Enable static stop loss per position

    # ENABLE_TRAILING_POSITION_SL: Trails the price of your individual position
    # Moves the stop-loss as price moves in your favor
    # Operates at the position level (per trade)
    ENABLE_TRAILING_POSITION_SL = False
    TRAILING_POSITION_SL_POINTS = 100  # Increased from 20 if you enable it

    # --- Account Equity Protection Settings ---
    # The hard stop was triggering with a $384 loss on a position that moved IN FAVOR
    # This suggests a broker configuration issue with contract multiplier
    # ENABLE_EQUITY_STOP: Tracks maximum account drawdown from all-time peak
    # Set MAX_DRAWDOWN_PERCENT to limit overall account risk
    ENABLE_EQUITY_STOP = True  # Set to True once broker multiplier is confirmed
    MAX_DRAWDOWN_PERCENT = 1.5  # Increased to 10% while debugging (was 3.0%)

    ENABLE_TRAILING_EQUITY_STOP = False
    # The trailing equity stop ONLY tracks equity when you have an open position, and it resets to None when flat. This means:
    # It's designed to protect profits on individual trades, not overall account drawdown
    # It measures the drop from the peak while a position is open, not from your account's all-time high
    # When you close a position and open a new one, the peak resets
    TRAILING_EQUITY_DROP_PERCENT = 0.5
    MAX_TRAILING_STOPS = 3

    # --- Position Sizing Limits ---
    # Optimized for $10k account with 0.01 lot minimum:
    # - Single position: 0.01 lots = ~$3,857 (38.57% of account)
    # - Grid (2 positions): 0.01 + 0.0105 lots = ~$7,907 (79.07% of account)
    # - Grid (3 positions): Would require ~$12,159 (121.59% - needs leverage)
    # Increasing this will allow us to trade with larger lots , but involves more risk
    MAX_POSITION_SIZE_PERCENT = 150.0  # Allows 2 grid positions with margin buffer
    
    TRADING_DIRECTION = 0
    MAX_SPREAD_POINTS = 20
    ENABLE_TREND_FILTER = False
    MA_PERIOD = 100
    MA_METHOD = 1
    MA_APPLIED_PRICE = 1
    ENABLE_TIME_FILTER = True
    START_HOUR = 20  # Optimized time filter: 4-13 (best P&L and profit factor)
    END_HOUR = 13   # Optimized time filter: 4-13 (best P&L and profit factor)

    # --- Indicator Settings ---
    ATR_PERIOD = 14

    # --- Entry Timing Fixes ---
    # Fix A: Enter at breakout START (open) instead of END (close)
    ENTER_ON_OPEN = True  # Enter at bar open (breakout start) vs bar close (breakout end)
    
    # Fix B: Wait for pullback before entering (limit order behavior)
    USE_LIMIT_ENTRY = False  # Wait for 50% retracement before entering
    LIMIT_RETRACEMENT_PERCENT = 50.0  # Wait for 50% pullback of big candle
    
    # Fix C: Momentum confirmation filters
    USE_MOMENTUM_FILTER = False  # Confirm breakout strength before entering
    MIN_CANDLE_BODY_RATIO = 0.7  # Candle must close in top/bottom 30% (0.7 = 70%)
    CHECK_VOLUME = False  # Require above-average volume (needs volume data)
    MAX_EXHAUSTION_RATIO = 3.0  # Reject if big candle > 3x average (exhausted move)
    
    # --- Counter-Trend Fade Strategy ---
    # Fade breakouts instead of following them (sells breakouts, buys breakdowns)
    # Logic: Big bullish candle = exhaustion/retail trap → SELL to fade
    #        Big bearish candle = exhaustion/retail trap → BUY to fade
    ENABLE_COUNTER_TREND_FADE = False  # Set to True to reverse entry direction
    
    # --- Signal Invalidation Protection ---
    # Exit immediately if large opposite candle forms within N bars after entry
    # Prevents catastrophic losses when market rejects the breakout signal
    ENABLE_SIGNAL_INVALIDATION = True  # Enable early exit on signal reversal
    INVALIDATION_WINDOW_BARS = 3  # Monitor for invalidation within N bars of entry

    # --- Logging Settings ---
    LOG_LEVEL = logging.INFO  # INFO for production, DEBUG for development
    LOG_FILE = None  # Set to file path for file logging, e.g., "/var/log/trading_bot.log"
    DEBUG_EQUITY = False  # Set to True to enable verbose equity calculation logging
    
    def __init__(self):
        # Setup logging
        self.logger = logging.getLogger(f"{self.__class__.__name__}_{id(self)}")
        self.logger.setLevel(self.LOG_LEVEL)
        
        # Remove existing handlers to avoid duplicates
        self.logger.handlers.clear()
        
        # Create formatter with timestamp
        formatter = logging.Formatter(
            '%(asctime)s [%(levelname)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        self.logger.addHandler(console_handler)
        
        # File handler (optional)
        if self.LOG_FILE:
            file_handler = logging.FileHandler(self.LOG_FILE)
            file_handler.setFormatter(formatter)
            self.logger.addHandler(file_handler)
        
        self.logger.info("=" * 60)
        self.logger.info(f"Initializing {self.__class__.__name__}")
        self.logger.info(f"Log Level: {logging.getLevelName(self.LOG_LEVEL)}")
        
        # Validate mutually exclusive settings
        if self.ENABLE_POSITION_SL and self.ENABLE_TRAILING_POSITION_SL:
            raise ValueError(
                "Configuration Error: Cannot enable both ENABLE_POSITION_SL and ENABLE_TRAILING_POSITION_SL. "
                "Choose one stop-loss method. Set one to False."
            )
        
        if self.ENABLE_EQUITY_STOP and self.ENABLE_TRAILING_EQUITY_STOP:
            raise ValueError(
                "Configuration Error: Cannot enable both ENABLE_EQUITY_STOP and ENABLE_TRAILING_EQUITY_STOP. "
                "Choose one equity protection method. Set one to False."
            )
        
        if self.USE_ATR_CALCULATION and self.USE_PERCENTILE_CALCULATION:
            raise ValueError(
                "Configuration Error: Cannot enable both USE_ATR_CALCULATION and USE_PERCENTILE_CALCULATION. "
                "Choose one adaptive candle sizing method. Set one to False."
            )
        
        # ATR-based TP/SL and trailing stops are incompatible
        # ATR-based uses dynamic distances (e.g., 1.0 x ATR = 50 points today, 60 points tomorrow)
        # Trailing uses fixed TRAILING_POSITION_SL_POINTS (always same distance)
        # Mixing these creates inconsistency and unpredictable behavior
        if self.USE_ATR_TP_SL and self.ENABLE_TRAILING_POSITION_SL:
            raise ValueError(
                "Configuration Error: Cannot enable both USE_ATR_TP_SL and ENABLE_TRAILING_POSITION_SL. "
                "ATR-based TP/SL uses dynamic distances (adapts to volatility), "
                "but trailing SL uses fixed TRAILING_POSITION_SL_POINTS (static distance). "
                "This creates inconsistency. Choose one approach: "
                "\n  1) USE_ATR_TP_SL=True with ENABLE_POSITION_SL=True (ATR-based static SL - RECOMMENDED)"
                "\n  2) USE_ATR_TP_SL=False with ENABLE_TRAILING_POSITION_SL=True (fixed-point trailing SL)"
            )
        
        data = self.datas[0]
        self.data_close = data.close
        self.data_high = data.high
        self.data_low = data.low
        self.data_open = data.open
        self.data_datetime = data.datetime

        # Point size estimation: Backtrader doesn't provide symbol point
        # Assume 1 pip = 0.01 for 2-decimal instruments and 0.0001 for FX; fallback to price resolution.
        self.point = self._infer_point()

        # Bid/Ask presence for spread filtering
        self._has_bidask = hasattr(data, 'ask') and hasattr(data, 'bid')

        # Trend MA
        if self.MA_METHOD == 1:
            self.ma = bt.ind.EMA(data, period=self.MA_PERIOD)
        else:
            self.ma = bt.ind.SMA(data, period=self.MA_PERIOD)

        # ATR for grid spacing
        self.atr = bt.ind.ATR(data, period=self.ATR_PERIOD)

        # Track peak portfolio value for equity stops - SEPARATED for each mechanism
        self.hard_stop_peak = None  # For hard drawdown stop (from initial balance)
        self.trailing_equity_peak = None  # For trailing equity stop (from position peak)
        self.equity_stop_triggered = False  # Flag to stop trading after equity stop
        self.consecutive_trailing_stops = 0  # Count consecutive trailing equity stops

        # Track our entries for grid management
        self._entries: List[dict] = []  # {dir: 1|-1, entry: float, tp: Optional[float], sl: Optional[float]}
        self._last_entry_price = None  # Track last entry for grid spacing

        # Trailing stop tracking
        self.trailing_stop_level = None  # Track current trailing SL level
        
        # New bar detection
        self.last_bar_datetime = None
        
        # Adaptive candle size tracking
        self.candle_ranges = []  # Buffer for percentile calculation
        self.bar_count = 0  # Track bars for percentile recalculation
        self.adaptive_big_candle = self.BIG_CANDLE_POINTS  # Current adaptive threshold
        self.adaptive_small_candle = self.SMALL_CANDLE_POINTS  # Current adaptive threshold
        
        # Limit order tracking (Fix B)
        self.pending_limit_order = None  # {direction: 1|-1, limit_price: float, signal_bar: int}
        
        # Signal invalidation tracking
        self.entry_bar_datetime = None  # Track when we entered (for invalidation window)

    # Order and Trade Notifications
    def notify_order(self, order):
        """Track order lifecycle - remove failed orders from tracking"""
        if order.status in [order.Submitted, order.Accepted]:
            return
        
        if order.status in [order.Completed]:
            # Order successfully filled
            if order.isbuy():
                self.log(f"BUY filled: {order.executed.size:.5f} @ {order.executed.price:.5f}")
            else:
                self.log(f"SELL filled: {order.executed.size:.5f} @ {order.executed.price:.5f}")
        
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            # Order failed - remove from tracking (was added optimistically on submission)
            if self._entries:
                self._entries.pop()
                self._last_entry_price = self._entries[-1]['entry'] if self._entries else None
                self.log(f"Order {order.getstatusname()}: Removed from tracking ({len(self._entries)} remaining)", "WARNING")
    
    def notify_trade(self, trade):
        """Log P&L when positions close"""
        if trade.isclosed:
            self.log(f"Trade closed: P&L=${trade.pnl:.2f}")
    
    # Utilities
    def _infer_point(self) -> float:
        # Try to infer from data price decimals
        # Get two recent closes and compute minimal tick
        lookback = min(len(self.datas[0]), 10)
        if lookback >= 2:
            diffs = []
            for i in range(1, lookback):
                d = abs(self.datas[0].close[-i] - self.datas[0].close[-i - 1])
                if d > 0:
                    diffs.append(d)
            if diffs:
                min_step = min(diffs)
                # round to nearest power of 10 step
                for p in [1e-5, 1e-4, 1e-3, 1e-2, 1e-1]:
                    if min_step >= p:
                        return p
        return 1e-2

    def _spread_points(self) -> float:
        if self._has_bidask:
            try:
                spread_price = float(self.datas[0].ask[0] - self.datas[0].bid[0])
                if self.point > 0:
                    return spread_price / self.point
            except Exception:
                return 0.0
        return 0.0

    def log(self, txt: str, level: str = "INFO") -> None:
        """
        Log a message with specified level.
        
        Args:
            txt: Message to log
            level: Log level - "DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"
        """
        level_upper = level.upper()
        if level_upper == "DEBUG":
            self.logger.debug(txt)
        elif level_upper == "WARNING":
            self.logger.warning(txt)
        elif level_upper == "ERROR":
            self.logger.error(txt)
        elif level_upper == "CRITICAL":
            self.logger.critical(txt)
        else:  # Default to INFO
            self.logger.info(txt)
    
    def _get_true_equity(self) -> float:
        """
        Calculate true account equity (cash + unrealized P&L).
        
        Note: broker.getvalue() returns available balance (cash - margin reserved),
        which is incorrect for drawdown tracking. This method calculates actual equity.
        """
        cash = self.broker.get_cash()
        
        if self.position.size == 0:
            return cash
        
        # Calculate unrealized P&L manually
        CONTRACT_SIZE = 100  # XAUUSD: 1 lot = 100 oz
        unrealized_pnl = self.position.size * (self.data_close[0] - self.position.price) * CONTRACT_SIZE
        true_equity = cash + unrealized_pnl
        
        # Verbose logging for debugging (enable with DEBUG_EQUITY = True)
        if self.DEBUG_EQUITY and len(self.data_close) % 100 == 0:
            self.log("=" * 60, "DEBUG")
            self.log("TRUE EQUITY CALCULATION:", "DEBUG")
            self.log(f"   Available Balance (broker): ${self.broker.getvalue():.2f}", "DEBUG")
            self.log(f"   Cash: ${cash:.2f}", "DEBUG")
            self.log(f"   Unrealized P&L: ${unrealized_pnl:.2f}", "DEBUG")
            self.log(f"   True Equity: ${true_equity:.2f}", "DEBUG")
            self.log("=" * 60, "DEBUG")
        
        return true_equity
    
    def _log_position_state(self) -> None:
        """Log current position state from broker for verification"""
        if self.position.size == 0:
            return
        
        CONTRACT_SIZE = 100  # XAUUSD: 1 lot = 100 oz
        current_price = self.data_close[0]
        position_pnl = self.position.size * (current_price - self.position.price) * CONTRACT_SIZE
        true_equity = self._get_true_equity()
        
        self.log("POSITION STATE:")
        self.log(f"   Size: {self.position.size:.5f} lots | Price: {self.position.price:.5f} | P&L: ${position_pnl:.2f}")
        self.log(f"   Equity: ${true_equity:.2f} | Tracked Entries: {len(self._entries)}")
        
        # Verbose breakdown (enable with DEBUG_EQUITY = True)
        if self.DEBUG_EQUITY:
            position_value = abs(self.position.size) * current_price * CONTRACT_SIZE
            available_balance = self.broker.getvalue()
            self.log(f"   [DEBUG] Notional: ${position_value:.2f} ({(position_value / true_equity * 100.0):.1f}%)", "DEBUG")
            self.log(f"   [DEBUG] Available Balance: ${available_balance:.2f} | Margin: ${true_equity - available_balance:.2f}", "DEBUG")
    
    def _update_adaptive_candle_sizes(self) -> None:
        """Update candle size thresholds based on selected adaptive method"""
        if self.USE_ATR_CALCULATION:
            self._update_atr_based_thresholds()
        elif self.USE_PERCENTILE_CALCULATION:
            self._update_percentile_based_thresholds()
    
    def _update_atr_based_thresholds(self) -> None:
        """ATR-based adaptive candle sizing (updates every bar automatically)"""
        current_atr = float(self.atr[0])
        if current_atr <= 0:
            return
        
        # Convert ATR (price units) to points
        atr_in_points = current_atr / self.point
        
        self.adaptive_small_candle = self.ATR_SMALL_MULTIPLIER * atr_in_points
        self.adaptive_big_candle = self.ATR_BIG_MULTIPLIER * atr_in_points
        
        # Log changes periodically (every 100 bars to avoid spam)
        if len(self.data_close) % 100 == 0:
            self.log(f"ATR Adaptive Update: Small={self.adaptive_small_candle:.1f}pts, Big={self.adaptive_big_candle:.1f}pts (ATR={atr_in_points:.1f}pts)")
    
    def _update_percentile_based_thresholds(self) -> None:
        """Percentile-based adaptive candle sizing (recalculates every N bars)"""
        current_range = abs(self.data_high[0] - self.data_low[0])
        self.candle_ranges.append(current_range)
        self.bar_count += 1
        
        # Maintain rolling window
        if len(self.candle_ranges) > self.PERCENTILE_LOOKBACK:
            self.candle_ranges.pop(0)
        
        # Recalculate every N bars and only if we have enough data
        if self.bar_count % self.PERCENTILE_UPDATE_FREQ == 0 and len(self.candle_ranges) >= self.PERCENTILE_LOOKBACK:
            sorted_ranges = sorted(self.candle_ranges)
            
            # Calculate percentile indices
            small_idx = int(self.SMALL_CANDLE_PERCENTILE / 100.0 * len(sorted_ranges))
            big_idx = int(self.BIG_CANDLE_PERCENTILE / 100.0 * len(sorted_ranges))
            
            # Convert from price units to points
            self.adaptive_small_candle = sorted_ranges[small_idx] / self.point
            self.adaptive_big_candle = sorted_ranges[big_idx] / self.point
            
            self.log(f"Percentile Adaptive Update: Small={self.adaptive_small_candle:.1f}pts ({self.SMALL_CANDLE_PERCENTILE}th%), Big={self.adaptive_big_candle:.1f}pts ({self.BIG_CANDLE_PERCENTILE}th%)")

    # Entry logic is evaluated on each bar
    def next(self):
        # Stop all trading if equity stop was triggered
        if self.equity_stop_triggered:
            return
        
        # 0) Update adaptive candle sizes if enabled
        if self.USE_ATR_CALCULATION or self.USE_PERCENTILE_CALCULATION:
            self._update_adaptive_candle_sizes()
            
        # 1) Equity stops - CHECK DRAWDOWN LIMIT FIRST
        if self.ENABLE_EQUITY_STOP:
            self._check_equity_drawdown_stop()
            # Check if we're AT THE LIMIT right now (prevents new entries)
            if self._should_stop_for_drawdown():
                if self.position.size != 0:
                    self.close()
                return
        
        if self.ENABLE_TRAILING_EQUITY_STOP:
            self._check_trailing_equity_stop()
            if self.equity_stop_triggered:
                return
        
        # 2) Signal invalidation check - exit early if large opposite candle forms after entry
        if self._check_signal_invalidation():
            return  # Position closed due to invalidation, don't process further

        # 3) Trailing stop per-position - works for all positions
        if self.ENABLE_TRAILING_POSITION_SL and self.position.size != 0:
            if self._trail_individual_stop():
                return  # Position closed, don't process new entries this bar

        # 4) Manage active positions (runs every tick)
        if self.position.size != 0:
            # Log actual broker position state periodically (every 10 bars)
            if len(self.data_close) % 10 == 0:
                self._log_position_state()
            
            # ALWAYS check individual TP/SL first
            if self._manage_single_targets():
                return  # Position closed, don't process new entries this bar
            
            # THEN optionally check grid basket logic
            if self.ENABLE_GRID and len(self._entries) > 1:
                if self._manage_grid():
                    return  # Position closed, don't process new entries this bar
        else:
            # Flat - clear any cached entries (handles desync from failed orders)
            if self._entries:
                self._entries.clear()
                self.trailing_stop_level = None
                self._last_entry_price = None
                self.entry_bar_datetime = None  # Clear invalidation tracking when flat

        # 5) Check pending limit orders (Fix B) - runs every tick when there's a pending order
        if self.USE_LIMIT_ENTRY and self.pending_limit_order is not None:
            if self._check_limit_order():
                return  # Limit order filled or cancelled, don't process new signals

        # 6) Check for new entry signals ONLY on new completed bars
        if not self._is_new_bar():
            return

        # 7) Time filter
        if self.ENABLE_TIME_FILTER:
            hour = self.data_datetime.time(0).hour
            # Handle time windows that cross midnight (e.g., START_HOUR=20, END_HOUR=5)
            if self.START_HOUR <= self.END_HOUR:
                # Normal case: trade between START_HOUR and END_HOUR
                if hour < self.START_HOUR or hour >= self.END_HOUR:
                    return
            else:
                # Crosses midnight: trade if hour >= START_HOUR OR hour < END_HOUR
                if hour < self.START_HOUR and hour >= self.END_HOUR:
                    return

        # 8) Spread filter using bid/ask when available
        if self.MAX_SPREAD_POINTS is not None:
            spread_pts = self._spread_points()
            if spread_pts > self.MAX_SPREAD_POINTS:
                self.log(f"Spread too high: {spread_pts:.2f} > {self.MAX_SPREAD_POINTS}")
                return

        # 9) Check pattern on completed bars: use [-1] and [-2]
        # Need at least 2 completed bars
        if len(self.data_close) < 2:
            return

        # Bars: setup = -2 (older), trigger = -1 (most recent completed)
        big_candle_size = abs(self.data_high[-1] - self.data_low[-1])
        small_candle_size = abs(self.data_high[-2] - self.data_low[-2])
        
        # Use adaptive thresholds if enabled, otherwise use static values
        big_threshold = self.adaptive_big_candle * self.point
        small_threshold = self.adaptive_small_candle * self.point

        if big_candle_size >= big_threshold and small_candle_size <= small_threshold:
            bullish_setup = self.data_close[-2] > self.data_open[-2]
            bearish_setup = self.data_close[-2] < self.data_open[-2]

            # Fix C: Momentum confirmation filters
            if self.USE_MOMENTUM_FILTER:
                if not self._confirm_momentum(bullish_setup):
                    return

            # Trend check using most recent completed bar
            allow_buy = self.TRADING_DIRECTION in (0, 1)
            allow_sell = self.TRADING_DIRECTION in (0, 2)
            trend_up = self.data_close[-1] > self.ma[-1]

            # Counter-Trend Fade: Reverse entry direction to fade breakouts
            if self.ENABLE_COUNTER_TREND_FADE:
                # FADE LOGIC: Big bullish candle = SELL, big bearish candle = BUY
                if bullish_setup and allow_sell and (not self.ENABLE_TREND_FILTER or trend_up):
                    # Bullish breakout detected → SELL (fade the move)
                    if self.USE_LIMIT_ENTRY:
                        self._create_limit_order(is_buy=False)
                    else:
                        self._open_trade(is_buy=False)
                elif bearish_setup and allow_buy and (not self.ENABLE_TREND_FILTER or not trend_up):
                    # Bearish breakout detected → BUY (fade the move)
                    if self.USE_LIMIT_ENTRY:
                        self._create_limit_order(is_buy=True)
                    else:
                        self._open_trade(is_buy=True)
            else:
                # STANDARD LOGIC: Follow breakouts
                if bullish_setup and allow_buy and (not self.ENABLE_TREND_FILTER or trend_up):
                    # Fix B: Use limit order entry (wait for pullback) or immediate entry
                    if self.USE_LIMIT_ENTRY:
                        self._create_limit_order(is_buy=True)
                    else:
                        self._open_trade(is_buy=True)
                elif bearish_setup and allow_sell and (not self.ENABLE_TREND_FILTER or not trend_up):
                    # Fix B: Use limit order entry (wait for pullback) or immediate entry
                    if self.USE_LIMIT_ENTRY:
                        self._create_limit_order(is_buy=False)
                    else:
                        self._open_trade(is_buy=False)
    
    def _is_new_bar(self) -> bool:
        """Check if a new bar has formed (mimics MT5 IsNewBar)"""
        current_dt = self.data_datetime.datetime(0)
        if self.last_bar_datetime != current_dt:
            self.last_bar_datetime = current_dt
            return True
        return False
    
    def _confirm_momentum(self, is_bullish: bool) -> bool:
        """
        Fix C: Confirm breakout momentum before entering
        Returns True if momentum is strong enough, False otherwise
        """
        # Check the big candle (trigger bar = -1)
        candle_open = self.data_open[-1]
        candle_close = self.data_close[-1]
        candle_high = self.data_high[-1]
        candle_low = self.data_low[-1]
        candle_range = candle_high - candle_low
        
        if candle_range <= 0:
            self.log("Momentum filter: Zero range candle rejected", "DEBUG")
            return False
        
        # 1. Check candle body ratio (must close near high for bulls, near low for bears)
        if is_bullish:
            # For bullish: candle should close in top 30% (body ratio > 0.7)
            body_position = (candle_close - candle_low) / candle_range
            if body_position < self.MIN_CANDLE_BODY_RATIO:
                self.log(f"Momentum filter: Bullish candle body ratio {body_position:.2f} < {self.MIN_CANDLE_BODY_RATIO}", "DEBUG")
                return False
        else:
            # For bearish: candle should close in bottom 30% (body ratio > 0.7 from top)
            body_position = (candle_high - candle_close) / candle_range
            if body_position < self.MIN_CANDLE_BODY_RATIO:
                self.log(f"Momentum filter: Bearish candle body ratio {body_position:.2f} < {self.MIN_CANDLE_BODY_RATIO}", "DEBUG")
                return False
        
        # 2. Check for exhaustion (candle too large compared to average)
        if self.MAX_EXHAUSTION_RATIO > 0:
            current_atr = float(self.atr[-1])  # Use ATR from trigger bar
            if current_atr > 0:
                exhaustion_ratio = candle_range / current_atr
                if exhaustion_ratio > self.MAX_EXHAUSTION_RATIO:
                    self.log(f"Momentum filter: Exhaustion detected {exhaustion_ratio:.2f}x ATR > {self.MAX_EXHAUSTION_RATIO}x", "DEBUG")
                    return False
        
        # 3. Optional: Check volume (if available)
        if self.CHECK_VOLUME and hasattr(self.datas[0], 'volume'):
            # Add volume check here if needed
            pass
        
        self.log(f"Momentum filter: PASSED for {'bullish' if is_bullish else 'bearish'} breakout", "DEBUG")
        return True
    
    def _check_signal_invalidation(self) -> bool:
        """
        Signal Invalidation Logic:
        
        After entering a position, monitor the next few bars. If a large candle forms
        in the OPPOSITE direction of our signal, exit immediately. This prevents getting
        stuck in trades where the market immediately rejects the breakout.
        
        Example: 
        - Pattern: Small candle + big bullish candle → Strategy goes LONG
        - Next bar: Large bearish candle forms → INVALIDATION, exit immediately
        
        This addresses the detection-execution gap where we enter based on bars [-2,-1]
        but bar [0] and beyond may contradict the signal.
        
        Returns True if position was closed due to invalidation, False otherwise.
        """
        # Skip if feature is disabled
        if not self.ENABLE_SIGNAL_INVALIDATION:
            return False
        
        if self.position.size == 0:
            return False
        
        # Only check within invalidation window after entry
        if self.entry_bar_datetime is None:
            return False
        
        # Calculate bars since entry using datetime comparison
        current_dt = self.data_datetime.datetime(0)
        time_delta = (current_dt - self.entry_bar_datetime)

        # Get bar period in seconds by comparing current and previous bars
        try:
            prev_dt = self.data_datetime.datetime(-1)
            bar_period_seconds = (current_dt - prev_dt).total_seconds()
        except:
            bar_period_seconds = 60  # Default to 1 minute for 1-minute bars

        if bar_period_seconds <= 0:
            bar_period_seconds = 60  # Default to 1 minute if unable to determine

        bars_since_entry = time_delta.total_seconds() / bar_period_seconds
        
        # Stop checking after invalidation window expires
        if bars_since_entry > self.INVALIDATION_WINDOW_BARS:
            self.entry_bar_datetime = None  # Clear to stop checking
            self.log(f"Signal invalidation window expired ({self.INVALIDATION_WINDOW_BARS} bars). No invalidation detected.", "DEBUG")
            return False
        
        # Check the most recent COMPLETED bar for invalidation (bar [-1])
        # We can't check bar [0] as it's still forming during backtesting
        if len(self.data_close) < 1:
            return False
        
        # Get the most recent completed bar's characteristics
        recent_high = self.data_high[-1]
        recent_low = self.data_low[-1]
        recent_open = self.data_open[-1]
        recent_close = self.data_close[-1]
        recent_range = abs(recent_high - recent_low)
        
        # Define "large candle" threshold (use same logic as pattern detection)
        if self.USE_ATR_CALCULATION or self.USE_PERCENTILE_CALCULATION:
            large_threshold = self.adaptive_big_candle * self.point
        else:
            large_threshold = self.BIG_CANDLE_POINTS * self.point
        
        # Check if recent bar is large AND moving opposite to our position
        if recent_range >= large_threshold:
            direction_is_long = self.position.size > 0
            candle_is_bearish = recent_close < recent_open
            candle_is_bullish = recent_close > recent_open
            
            # Invalidation condition: large candle in opposite direction
            invalidation_detected = (direction_is_long and candle_is_bearish) or (not direction_is_long and candle_is_bullish)
            
            if invalidation_detected:
                current_price = self.data_close[0]
                entry_price = self._entries[-1]['entry'] if self._entries else self.position.price
                pnl_points = (current_price - entry_price) * (1 if direction_is_long else -1) / self.point
                
                self.log("=" * 60, "WARNING")
                self.log("⚠️  SIGNAL INVALIDATION DETECTED!", "WARNING")
                self.log(f"   Position: {'LONG' if direction_is_long else 'SHORT'} @ {entry_price:.5f}", "WARNING")
                self.log(f"   Invalidation Bar: {'BEARISH' if candle_is_bearish else 'BULLISH'} candle (Range: {recent_range / self.point:.1f} pts)", "WARNING")
                self.log(f"   Threshold: {large_threshold / self.point:.1f} pts (Big candle definition)", "WARNING")
                self.log(f"   Current Price: {current_price:.5f} | P&L: {pnl_points:+.1f} pts", "WARNING")
                self.log(f"   Bars Since Entry: {int(bars_since_entry)}", "WARNING")
                self.log("   → Closing position immediately to prevent catastrophic loss", "WARNING")
                self.log("=" * 60, "WARNING")
                
                self.close()
                self.entry_bar_datetime = None  # Clear tracking
                return True
        
        return False
    
    def _create_limit_order(self, is_buy: bool):
        """
        Fix B: Create a pending limit order at pullback level
        Instead of entering immediately, wait for price to retrace 50% of big candle
        """
        # Calculate 50% retracement of the big candle (bar -1)
        big_candle_high = self.data_high[-1]
        big_candle_low = self.data_low[-1]
        big_candle_mid = (big_candle_high + big_candle_low) / 2.0
        
        # Calculate retracement level (50% by default)
        retracement_factor = self.LIMIT_RETRACEMENT_PERCENT / 100.0
        
        if is_buy:
            # For bullish breakout, wait for pullback to 50% of big candle
            limit_price = big_candle_low + (big_candle_high - big_candle_low) * retracement_factor
            direction_str = "BUY"
        else:
            # For bearish breakout, wait for pullback to 50% of big candle
            limit_price = big_candle_high - (big_candle_high - big_candle_low) * retracement_factor
            direction_str = "SELL"
        
        # Store pending limit order
        self.pending_limit_order = {
            "direction": 1 if is_buy else -1,
            "limit_price": limit_price,
            "signal_bar": len(self.data_close),
            "is_buy": is_buy
        }
        
        self.log(f"LIMIT ORDER CREATED: {direction_str} @ {limit_price:.5f}")
        self.log(f"   Big Candle: Low={big_candle_low:.5f}, High={big_candle_high:.5f}, Mid={big_candle_mid:.5f}")
        self.log(f"   Waiting for {self.LIMIT_RETRACEMENT_PERCENT:.0f}% pullback to {limit_price:.5f}")
    
    def _check_limit_order(self) -> bool:
        """
        Fix B: Check if pending limit order should be filled or cancelled
        Returns True if order was processed (filled or cancelled), False otherwise
        """
        if self.pending_limit_order is None:
            return False
        
        current_bar = len(self.data_close)
        signal_bar = self.pending_limit_order["signal_bar"]
        bars_since_signal = current_bar - signal_bar
        
        # Cancel limit order after 5 bars (signal likely expired)
        MAX_BARS_PENDING = 5
        if bars_since_signal > MAX_BARS_PENDING:
            self.log(f"Limit order CANCELLED: {bars_since_signal} bars since signal (max {MAX_BARS_PENDING})")
            self.pending_limit_order = None
            return True
        
        # Check if price touched the limit level
        is_buy = self.pending_limit_order["is_buy"]
        limit_price = self.pending_limit_order["limit_price"]
        current_high = self.data_high[0]
        current_low = self.data_low[0]
        
        order_filled = False
        if is_buy:
            # For buy limit, check if price went down to or below limit
            if current_low <= limit_price:
                order_filled = True
        else:
            # For sell limit, check if price went up to or above limit
            if current_high >= limit_price:
                order_filled = True
        
        if order_filled:
            self.log(f"LIMIT ORDER FILLED @ {limit_price:.5f} (Current: {self.data_close[0]:.5f})")
            # Execute the trade at limit price
            self._open_trade(is_buy=is_buy, limit_price=limit_price)
            # Clear pending order
            self.pending_limit_order = None
            return True
        
        return False

    # Hard equity drawdown stop: close all when drawdown from peak exceeds threshold
    def _check_equity_drawdown_stop(self):
        """
        Update peak equity tracking only
        
        CRITICAL FIX: Use true equity (cash + unrealized P&L) instead of broker.getvalue()
        which reports available balance (cash - margin reserved) in live trading.
        """
        current_value = self._get_true_equity()  # FIX: Use true equity, not available balance
        
        if self.hard_stop_peak is None:
            self.hard_stop_peak = current_value
            self.log(f"Hard stop peak initialized: ${self.hard_stop_peak:.2f}")
            return
        
        if current_value > self.hard_stop_peak:
            self.hard_stop_peak = current_value
            self.log(f"Hard stop peak updated: ${self.hard_stop_peak:.2f}")
    
    def _should_stop_for_drawdown(self) -> bool:
        """
        Check if drawdown exceeds limit (uses true equity, not available balance).
        
        Note: broker.getvalue() reports available balance (cash - margin), which was
        causing false alarms where margin reservation was mistaken for drawdown.
        """
        if not self.ENABLE_EQUITY_STOP or self.hard_stop_peak is None:
            return False
        
        current_value = self._get_true_equity()
        drawdown_pct = (self.hard_stop_peak - current_value) / self.hard_stop_peak * 100.0
        
        # Periodic status logging (enable with DEBUG_EQUITY = True)
        if self.DEBUG_EQUITY and len(self.data_close) % 50 == 0 and self.position.size != 0:
            self.log(f"Drawdown: {drawdown_pct:.2f}% | Peak: ${self.hard_stop_peak:.2f} | Current: ${current_value:.2f}", "DEBUG")
        
        if drawdown_pct >= self.MAX_DRAWDOWN_PERCENT:
            self.log("=" * 60, "CRITICAL")
            self.log(f"DRAWDOWN LIMIT HIT: {drawdown_pct:.2f}% >= {self.MAX_DRAWDOWN_PERCENT:.2f}%", "CRITICAL")
            self.log(f"   Peak: ${self.hard_stop_peak:.2f} | Current: ${current_value:.2f} | Loss: ${self.hard_stop_peak - current_value:.2f}", "CRITICAL")
            
            # Show margin breakdown if debugging enabled
            if self.DEBUG_EQUITY:
                available_balance = self.broker.getvalue()
                self.log(f"   [DEBUG] Available Balance: ${available_balance:.2f} | Margin: ${current_value - available_balance:.2f}", "CRITICAL")
            
            self.log("=" * 60, "CRITICAL")
            self.equity_stop_triggered = True
            return True
        
        return False
    
    def _check_trailing_equity_stop(self):
        """
        Trailing equity stop: closes positions when equity drops X% from peak (locks in profits)
        
        CRITICAL FIX: Use true equity (cash + unrealized P&L) instead of broker.getvalue()
        which reports available balance (cash - margin reserved) in live trading.
        """
        current_value = self._get_true_equity()  # FIX: Use true equity, not available balance
        
        # Only activate trailing if we have an open position
        if self.position.size == 0:
            self.trailing_equity_peak = None  # Reset when flat
            return
            
        # Update peak only when in position
        if self.trailing_equity_peak is None or current_value > self.trailing_equity_peak:
            self.trailing_equity_peak = current_value
            self.log(f"Trailing equity peak updated: ${self.trailing_equity_peak:.2f}")
            # Reset counter when reaching new peak (profitable trade)
            if current_value > self.broker.startingcash:
                self.consecutive_trailing_stops = 0
            return
        
        # Calculate drop from peak
        drop_pct = (self.trailing_equity_peak - current_value) / self.trailing_equity_peak * 100.0
        if drop_pct >= self.TRAILING_EQUITY_DROP_PERCENT:
            self.log(
                f"TRAILING EQUITY STOP HIT #{self.consecutive_trailing_stops + 1}: Drop {drop_pct:.2f}% >= {self.TRAILING_EQUITY_DROP_PERCENT:.2f}% "
                f"(Peak: ${self.trailing_equity_peak:.2f}, Current: ${current_value:.2f}). Closing positions.",
                "WARNING"
            )
            # Close position
            if self.position.size != 0:
                self.close()
            
            # Increment counter
            self.consecutive_trailing_stops += 1
            
            # Stop all trading if max consecutive trailing stops reached
            if self.consecutive_trailing_stops >= self.MAX_TRAILING_STOPS:
                self.log(
                    f"MAX CONSECUTIVE TRAILING STOPS REACHED ({self.consecutive_trailing_stops}). "
                    f"STOPPING ALL TRADING.",
                    "CRITICAL"
                )
                self.equity_stop_triggered = True
            
            # Reset peak after closing
            self.trailing_equity_peak = None

    def _open_trade(self, is_buy: bool, limit_price: float = None):
        # Respect max open trades (use entry count, not position size calc)
        if len(self._entries) >= self.MAX_OPEN_TRADES:
            self.log(f"Max open trades reached: {len(self._entries)}")
            return

        # Calculate next position size
        size = self._next_lot_size()
        
        # Fix A & B: Determine entry price
        if limit_price is not None:
            # Fix B: Use limit price from pullback entry
            price = limit_price
            self.log(f"Entry Mode: LIMIT @ {price:.5f} (pullback entry)", "DEBUG")
        elif self.ENTER_ON_OPEN:
            # Fix A: Enter at breakout START (open) instead of END (close)
            price = self.data_open[0]  # Enter at current bar open (breakout start)
            self.log(f"Entry Mode: OPEN (catching breakout start)", "DEBUG")
        else:
            # Traditional: Enter at close
            price = self.data_close[0]  # Enter at current bar close (breakout end)
            self.log(f"Entry Mode: CLOSE (traditional)", "DEBUG")
        
        # Validate position size against account equity
        if not self._validate_position_size(size, price):
            return

        # Calculate TP and SL
        if self.USE_ATR_TP_SL:
            # ATR-based TP/SL (dynamic, adapts to volatility)
            current_atr = float(self.atr[0])
            tp_distance = self.TP_ATR_MULTIPLIER * current_atr
            sl_distance = self.SL_ATR_MULTIPLIER * current_atr if self.ENABLE_POSITION_SL else None
        else:
            # Fixed point-based TP/SL (static)
            tp_distance = self.TAKE_PROFIT_POINTS * self.point
            sl_distance = self.POSITION_SL_POINTS * self.point if self.ENABLE_POSITION_SL else None
        
        # Apply TP/SL to current price
        tp = None
        if is_buy:
            tp = price + tp_distance
        else:
            tp = price - tp_distance

        sl = None
        if self.ENABLE_POSITION_SL and sl_distance:
            if is_buy:
                sl = price - sl_distance
            else:
                sl = price + sl_distance

        # Calculate true notional value with contract size
        CONTRACT_SIZE = 100  # XAUUSD: 1 lot = 100 oz
        true_notional = size * price * CONTRACT_SIZE
        
        # Log trade details
        if self.USE_ATR_TP_SL:
            current_atr = float(self.atr[0])
            tp_sl_mode = f"ATR-based (ATR={current_atr:.2f}, TP={self.TP_ATR_MULTIPLIER}x, SL={self.SL_ATR_MULTIPLIER}x)"
        else:
            tp_sl_mode = f"Fixed points (TP={self.TAKE_PROFIT_POINTS}, SL={self.POSITION_SL_POINTS})"
        
        if is_buy:
            self.buy(size=size)
            self.log(f"BUY ORDER PLACED:")
            self.log(f"   Size: {size} broker units ({size * CONTRACT_SIZE:.2f} oz)")
            self.log(f"   Price: {price:.5f}")
            self.log(f"   TP: {tp:.5f} ({tp_sl_mode})" if tp else "   TP: None")
            self.log(f"   SL: {sl:.5f}" if sl else "   SL: None")
            self.log(f"   Notional Value: ${true_notional:.2f}")
        else:
            self.sell(size=size)
            self.log(f"SELL ORDER PLACED:")
            self.log(f"   Size: {size} broker units ({size * CONTRACT_SIZE:.2f} oz)")
            self.log(f"   Price: {price:.5f}")
            self.log(f"   TP: {tp:.5f} ({tp_sl_mode})" if tp else "   TP: None")
            self.log(f"   SL: {sl:.5f}" if sl else "   SL: None")
            self.log(f"   Notional Value: ${true_notional:.2f}")

        # Cache intended TP/SL levels on strategy for management
        self._last_entry_price = price
        # track entry record
        self._entries.append({
            "dir": 1 if is_buy else -1,
            "entry": price,
            "tp": tp,
            "sl": sl,
        })
        
        # Track entry time for signal invalidation monitoring
        if self.ENABLE_SIGNAL_INVALIDATION:
            self.entry_bar_datetime = self.data_datetime.datetime(0)
        
        # Log position tracking info
        self.log(f"   Entry #{len(self._entries)} tracked (Total entries: {len(self._entries)})")
        if self.ENABLE_SIGNAL_INVALIDATION:
            self.log(f"   Signal invalidation monitoring: Active for next {self.INVALIDATION_WINDOW_BARS} bars")

    def _next_lot_size(self) -> float:
        """
        Calculate next lot size for grid trading.
        Uses LOT_SIZE with LOT_MULTIPLIER for grid recovery.
        Respects broker's minimum lot size and lot step requirements.
        """
        # Apply grid multiplier for subsequent positions
        entries = len(self._entries)
        calculated_size = self.LOT_SIZE * (self.LOT_MULTIPLIER ** entries)
        
        # Round to broker's lot step (e.g., 0.01)
        if self.LOT_STEP > 0:
            rounded_size = round(calculated_size / self.LOT_STEP) * self.LOT_STEP
        else:
            rounded_size = calculated_size
        
        # Ensure meets minimum lot size
        final_size = max(self.MIN_LOT_SIZE, rounded_size)
        
        return round(final_size, 5)
    
    def _validate_position_size(self, new_size: float, price: float) -> bool:
        """
        Validate that adding new position won't exceed maximum position size limits.
        Uses true equity (cash + unrealized P&L) for accurate validation.
        """
        CONTRACT_SIZE = 100  # XAUUSD: 1 lot = 100 oz
        
        # Calculate position values
        current_position_value = abs(self.position.size) * price * CONTRACT_SIZE if self.position.size != 0 else 0.0
        new_position_value = new_size * price * CONTRACT_SIZE
        total_position_value = current_position_value + new_position_value
        
        # Get true account equity and calculate limits
        account_equity = self._get_true_equity()
        max_position_value = account_equity * (self.MAX_POSITION_SIZE_PERCENT / 100.0)
        utilization_pct = (total_position_value / max_position_value * 100.0)
        
        # Log validation decision
        self.log(f"Position Size Check: {new_size:.5f} lots @ {price:.5f} = ${new_position_value:.2f} | Utilization: {utilization_pct:.1f}%")
        
        # Validate against limit
        if total_position_value > max_position_value:
            self.log(f"REJECTED: Position would exceed {self.MAX_POSITION_SIZE_PERCENT}% limit (${total_position_value:.2f} > ${max_position_value:.2f})", "ERROR")
            
            # Provide helpful suggestions for first position rejection
            if len(self._entries) == 0:
                min_required_percent = (new_position_value / account_equity * 100.0)
                self.log(f"Suggestions: Increase MAX_POSITION_SIZE_PERCENT to {min_required_percent:.1f}% OR reduce LOT_SIZE (currently {self.LOT_SIZE})", "WARNING")
            
            return False
        
        self.log(f"APPROVED: ${max_position_value - total_position_value:.2f} remaining capacity")
        
        # Verbose breakdown (enable with DEBUG_EQUITY = True)
        if self.DEBUG_EQUITY:
            available_balance = self.broker.getvalue()
            self.log(f"   [DEBUG] Equity: ${account_equity:.2f} | Available: ${available_balance:.2f} | Margin: ${account_equity - available_balance:.2f}", "DEBUG")
            self.log(f"   [DEBUG] Current Position: ${current_position_value:.2f} | New: ${new_position_value:.2f} | Total: ${total_position_value:.2f}", "DEBUG")
        
        return True

    def _manage_grid(self) -> bool:
        """
        Manage grid trading logic
        Returns True if position was closed, False otherwise
        """
        if not self.ENABLE_GRID:
            return False

        current_price = self.data_close[0]
        direction_is_long = self.position.size > 0
        
        # CRITICAL: Check grid basket stop-loss FIRST using average position price
        if self.ENABLE_POSITION_SL and self.position.size != 0:
            # Use Backtrader's average position price for grid basket SL
            avg_price = self.position.price
            sl_distance = self.POSITION_SL_POINTS * self.point
            
            if direction_is_long:
                basket_sl = avg_price - sl_distance
                if current_price <= basket_sl:
                    # CHECK DRAWDOWN BEFORE CLOSING
                    if self._should_stop_for_drawdown():
                        self.close()
                        return True
                    self.log(
                        f"Grid basket SL hit @ {current_price:.5f} "
                        f"(Avg: {avg_price:.5f}, SL: {basket_sl:.5f}). Closing all positions."
                    )
                    self.close()
                    return True
            else:
                basket_sl = avg_price + sl_distance
                if current_price >= basket_sl:
                    # CHECK DRAWDOWN BEFORE CLOSING
                    if self._should_stop_for_drawdown():
                        self.close()
                        return True
                    self.log(
                        f"Grid basket SL hit @ {current_price:.5f} "
                        f"(Avg: {avg_price:.5f}, SL: {basket_sl:.5f}). Closing all positions."
                    )
                    self.close()
                    return True

        # Count basket entries from tracked list
        entries = len(self._entries)
        if entries >= self.MAX_OPEN_TRADES:
            # Still update shared TP for the basket
            return self._update_shared_takeprofit()

        # Determine last entry price directionally and ATR-based step
        recovery_step = float(self.atr[0]) * self.ATR_MULTIPLIER_STEP
        if recovery_step <= 0:
            return False

        # Use last entry price from our tracked entries, or current price as fallback
        last_price = self._last_entry_price if self._last_entry_price is not None else current_price
        distance = abs(current_price - last_price)

        if distance >= recovery_step:
            # Optional trend re-check before adding
            trend_up = self.data_close[0] > self.ma[0]
            if self.ENABLE_TREND_FILTER and ((direction_is_long and not trend_up) or (not direction_is_long and trend_up)):
                self.log("Trend reversed. Halting grid recovery.")
                return False

            size = self._next_lot_size()
            
            # Validate position size before adding to grid
            if not self._validate_position_size(size, current_price):
                self.log("Grid recovery stopped: position size limit would be exceeded.")
                return False
            
            CONTRACT_SIZE = 100  # XAUUSD: 1 lot = 100 oz
            
            if direction_is_long:
                self.buy(size=size)
                self.log(f"GRID BUY RECOVERY #{len(self._entries) + 1}:")
                self.log(f"   Size: {size} broker units ({size * CONTRACT_SIZE:.2f} oz)")
                self.log(f"   Price: {current_price:.5f}")
                self.log(f"   Notional: ${size * current_price * CONTRACT_SIZE:.2f}")
                tp = None
                sl = (current_price - self.POSITION_SL_POINTS * self.point) if self.ENABLE_POSITION_SL else None
                self._entries.append({"dir": 1, "entry": current_price, "tp": tp, "sl": sl})
            else:
                self.sell(size=size)
                self.log(f"GRID SELL RECOVERY #{len(self._entries) + 1}:")
                self.log(f"   Size: {size} broker units ({size * CONTRACT_SIZE:.2f} oz)")
                self.log(f"   Price: {current_price:.5f}")
                self.log(f"   Notional: ${size * current_price * CONTRACT_SIZE:.2f}")
                tp = None
                sl = (current_price + self.POSITION_SL_POINTS * self.point) if self.ENABLE_POSITION_SL else None
                self._entries.append({"dir": -1, "entry": current_price, "tp": tp, "sl": sl})
            self._last_entry_price = current_price
            
            # Log updated total exposure
            self.log(f"   Total Grid Positions: {len(self._entries)}")
            self.log(f"   Average Entry: {self.position.price:.5f} (will update after execution)")

        # Always recompute basket TP
        return self._update_shared_takeprofit()

    def _update_shared_takeprofit(self) -> bool:
        """
        Update and check shared take profit for grid basket
        Returns True if position was closed, False otherwise
        """
        if self.position.size == 0:
            return False

        avg_price = self.position.price
        direction_is_long = self.position.size > 0
        
        # Use ATR-based or fixed points for grid TP (same as regular TP)
        if self.USE_ATR_TP_SL:
            current_atr = float(self.atr[0])
            grid_profit_offset = self.TP_ATR_MULTIPLIER * current_atr
        else:
            grid_profit_offset = self.GRID_PROFIT_POINTS * self.point
        
        if direction_is_long:
            breakeven_plus = avg_price + grid_profit_offset
        else:
            breakeven_plus = avg_price - grid_profit_offset

        # Manage TP by closing when price crosses target
        price = self.data_close[0]
        if (direction_is_long and price >= breakeven_plus) or (not direction_is_long and price <= breakeven_plus):
            # Check drawdown for consistent logging (TP is still profitable, so we close regardless)
            self._should_stop_for_drawdown()
            self.log(f"Basket TP reached @ {price:.5f} (Target: {breakeven_plus:.5f}). Closing position.")
            self.close()
            return True
        
        return False

    def _trail_individual_stop(self) -> bool:
        """
        Proper trailing stop: tracks highest/lowest and trails behind
        Returns True if position was closed, False otherwise
        """
        if self.position.size == 0 or not self.ENABLE_TRAILING_POSITION_SL:
            return False

        price = self.data_close[0]
        direction_is_long = self.position.size > 0
        trail_offset = self.TRAILING_POSITION_SL_POINTS * self.point

        if direction_is_long:
            # Initialize trailing stop on first call after opening position
            if self.trailing_stop_level is None:
                self.trailing_stop_level = price - trail_offset
                self.log(f"Initialized trailing SL (long) @ {self.trailing_stop_level:.5f}")
            else:
                # Update trailing stop only if price moves up
                new_trail = price - trail_offset
                if new_trail > self.trailing_stop_level:
                    self.trailing_stop_level = new_trail
                    self.log(f"Updated trailing SL (long) @ {self.trailing_stop_level:.5f}")
            
            # Check if price hit trailing stop
            if price <= self.trailing_stop_level:
                # CHECK DRAWDOWN BEFORE CLOSING
                if self._should_stop_for_drawdown():
                    self.close()
                    self.trailing_stop_level = None
                    return True
                self.log(f"Trailing SL hit (long) @ {price:.5f}, SL level: {self.trailing_stop_level:.5f}. Closing.")
                self.close()
                self.trailing_stop_level = None
                return True
        else:
            # Initialize trailing stop for short
            if self.trailing_stop_level is None:
                self.trailing_stop_level = price + trail_offset
                self.log(f"Initialized trailing SL (short) @ {self.trailing_stop_level:.5f}")
            else:
                # Update trailing stop only if price moves down
                new_trail = price + trail_offset
                if new_trail < self.trailing_stop_level:
                    self.trailing_stop_level = new_trail
                    self.log(f"Updated trailing SL (short) @ {self.trailing_stop_level:.5f}")
            
            # Check if price hit trailing stop
            if price >= self.trailing_stop_level:
                # CHECK DRAWDOWN BEFORE CLOSING
                if self._should_stop_for_drawdown():
                    self.close()
                    self.trailing_stop_level = None
                    return True
                self.log(f"Trailing SL hit (short) @ {price:.5f}, SL level: {self.trailing_stop_level:.5f}. Closing.")
                self.close()
                self.trailing_stop_level = None
                return True
        
        return False

    def _manage_single_targets(self) -> bool:
        """
        Manage single position TP/SL
        Returns True if position was closed, False otherwise
        """
        if self.position.size == 0 or not self._entries:
            return False
        price = self.data_close[0]
        entry = self._entries[-1]
        direction_is_long = self.position.size > 0

        # Static SL if enabled - CHECK THIS FIRST (most important)
        if self.ENABLE_POSITION_SL and entry.get("sl") is not None:
            sl_level = entry["sl"]
            if (direction_is_long and price <= sl_level) or (not direction_is_long and price >= sl_level):
                # CHECK DRAWDOWN BEFORE CLOSING
                if self._should_stop_for_drawdown():
                    self.close()
                    return True
                self.log(f"Static SL hit @ {price:.5f} (SL: {sl_level:.5f}). Closing single position.")
                self.close()
                return True

        # Take profit for single trade
        tp = entry.get("tp")
        if tp is not None:
            if (direction_is_long and price >= tp) or (not direction_is_long and price <= tp):
                self.log(f"Single trade TP reached @ {price:.5f} (TP: {tp:.5f}). Closing.")
                self.close()
                return True
        
        return False


# Convenience runner for local testing/backtest
def run_backtest(datafeed):
    cerebro = bt.Cerebro()
    cerebro.addstrategy(GoldCandleKenStrategy)
    cerebro.adddata(datafeed)
    cerebro.broker.setcash(100000.0)
    
    # CRITICAL: Configure broker with correct contract multiplier for XAUUSD
    # Without this, Backtrader will calculate P&L as if 0.01 units = $38.44 exposure
    # instead of 0.01 lots = 1 oz = $3,844 exposure (100x difference!)
    comminfo = bt.CommInfoBase(
        commission=0.0002,  # 0.02% commission
        mult=100.0,         # CONTRACT_SIZE: 1 lot = 100 oz for XAUUSD
        margin=True,        # Not using margin calc, TradeLocker handles this
        commtype=bt.CommInfoBase.COMM_PERC  # Percentage-based commission
    )
    cerebro.broker.addcommissioninfo(comminfo)
    
    return cerebro.run()


